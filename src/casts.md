# 변형

변형은 강제 변환을 포함하는 더 큰 개념입니다: 모든 강제 변환은 변형으로 명시적으로 호출할 수 있습니다. 하지만 어떤 변환들은 변형을 필요로 합니다. 강제 변환은 흔하고 보통은 위험하지 않지만, 이런 "진짜 변형"은 희귀하고, 위험할 수 있습니다. 
그런 면에서, 변형은 명시적으로 `as` 키워드를 사용해서 호출해야 합니다: `expr as Type`.

[모든 변형과][cast_list] [그 의미들은][semantics_list] 참조서에서 전체 목록을 볼 수 있습니다.

## 변형의 안전성

진정한 변형은 일반적으로 생 포인터들과 기초적인 수 타입들 주위를 맴돕니다. 위험하긴 하지만, 이 변형들은 실행 시에는 실패할 수 없습니다. 
만약 어떤 변형 작업이 어떤 특수한 경우를 발생시킨다면 이런 경우가 일어났다는 표시는 주어지지 않을 것입니다. 그 변형 작업은 그냥 성공하게 됩니다. 
그런 점에서 변형은 타입 단계에서 올바라야 하는데, 그렇지 않으면 컴파일 때에 방지될 것입니다. 예를 들어, `7u8 as bool`은 컴파일되지 않을 것입니다.

이러한 것들을 보았을 때, 변형은 `unsafe`하지는 않습니다, 왜냐하면 일반적으로 *그 자체로는* 메모리 안정성을 위배할 수 없기 때문이죠. 예를 들어, 어떤 정수를 생 포인터로 변환하는 것은 매우 쉽게 다른 끔찍한 일들로 이어질 수 있습니다. 
하지만 그 포인터를 만드는 것 자체는 안전한데, 생 포인터를 실제로 사용하는 작업이 이미 `unsafe`로 표시되었기 때문입니다.

## 변형에 대한 몇 가지 주의사항

### 생 슬라이스를 변형할 때의 길이

생 슬라이스를 변형할 때 길이가 조정되지 않는다는 점을 주의하세요: `*const [u16] as *const [u8]`은 원래 메모리의 절반만 포함하는 슬라이스를 만들어냅니다.

### 전이성

변형은 전이적이지 않습니다, 다시 말해, `e as U1 as U2`가 올바른 식이라고 해도, `e as U2`는 꼭 올바르지는 않을 수 있다는 겁니다.

[cast_list]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions
[semantics_list]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#semantics
